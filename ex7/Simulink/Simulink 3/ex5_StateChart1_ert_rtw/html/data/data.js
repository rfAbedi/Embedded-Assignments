var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"ex5_StateChart1","ref":false,"files":[{"name":"ex5_StateChart1.c","type":"source","group":"model","path":"C:\\Users\\erfuu\\OneDrive\\Courses\\Embedded and Realtime Systems\\Exercises\\ex7\\Simulink_3\\ex5_StateChart1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: ex5_StateChart1.c\r\n *\r\n * Code generated for Simulink model 'ex5_StateChart1'.\r\n *\r\n * Model version                  : 1.30\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 28 22:05:55 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"ex5_StateChart1.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"ex5_StateChart1_private.h\"\r\n#include <math.h>\r\n\r\n/* Named constants for Chart: '<Root>/Chart1' */\r\n#define ex5_StateC_IN_Counter_ClockWise ((uint8_T)2U)\r\n#define ex5_StateChart1_IN_ClockWise   ((uint8_T)1U)\r\n#define ex5_StateChart1_IN_Natural     ((uint8_T)3U)\r\n#define ex5_StateChart1_STEP_SIZE      (100U)\r\n\r\n/* Block states (default storage) */\r\nDW_ex5_StateChart1_T ex5_StateChart1_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU_ex5_StateChart1_T ex5_StateChart1_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_ex5_StateChart1_T ex5_StateChart1_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_ex5_StateChart1_T ex5_StateChart1_M_;\r\nRT_MODEL_ex5_StateChart1_T *const ex5_StateChart1_M = &ex5_StateChart1_M_;\r\nreal_T rt_roundd_snf(real_T u)\r\n{\r\n  real_T y;\r\n  if (fabs(u) < 4.503599627370496E+15) {\r\n    if (u >= 0.5) {\r\n      y = floor(u + 0.5);\r\n    } else if (u > -0.5) {\r\n      y = u * 0.0;\r\n    } else {\r\n      y = ceil(u - 0.5);\r\n    }\r\n  } else {\r\n    y = u;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid ex5_StateChart1_step(void)\r\n{\r\n  real_T tmp_0;\r\n  int16_T z;\r\n  uint16_T qY;\r\n  uint16_T tmp;\r\n\r\n  /* Chart: '<Root>/Chart1' incorporates:\r\n   *  Inport: '<Root>/switch_on'\r\n   */\r\n  if (ex5_StateChart1_DW.is_active_c2_ex5_StateChart1 == 0U) {\r\n    ex5_StateChart1_DW.is_active_c2_ex5_StateChart1 = 1U;\r\n    ex5_StateChart1_DW.is_Servo_Motor = ex5_StateChart1_IN_Natural;\r\n  } else {\r\n    switch (ex5_StateChart1_DW.is_Servo_Motor) {\r\n     case ex5_StateChart1_IN_ClockWise:\r\n      if (ex5_StateChart1_DW.ctr_servo >= 35U) {\r\n        /* Outport: '<Root>/servo_rotate' */\r\n        ex5_StateChart1_Y.servo_rotate = -1;\r\n        ex5_StateChart1_DW.ctr_servo = 0U;\r\n        ex5_StateChart1_DW.is_Servo_Motor = ex5_StateC_IN_Counter_ClockWise;\r\n      } else {\r\n        qY = ex5_StateChart1_DW.ctr_servo + /*MW:OvSatOk*/ 1U;\r\n        if (ex5_StateChart1_DW.ctr_servo + 1U < ex5_StateChart1_DW.ctr_servo) {\r\n          qY = MAX_uint16_T;\r\n        }\r\n\r\n        ex5_StateChart1_DW.ctr_servo = qY;\r\n        ex5_StateChart1_DW.is_Servo_Motor = ex5_StateChart1_IN_ClockWise;\r\n      }\r\n      break;\r\n\r\n     case ex5_StateC_IN_Counter_ClockWise:\r\n      if (ex5_StateChart1_DW.ctr_servo < 35U) {\r\n        qY = ex5_StateChart1_DW.ctr_servo + /*MW:OvSatOk*/ 1U;\r\n        if (ex5_StateChart1_DW.ctr_servo + 1U < ex5_StateChart1_DW.ctr_servo) {\r\n          qY = MAX_uint16_T;\r\n        }\r\n\r\n        ex5_StateChart1_DW.ctr_servo = qY;\r\n        ex5_StateChart1_DW.is_Servo_Motor = ex5_StateC_IN_Counter_ClockWise;\r\n      } else {\r\n        /* Outport: '<Root>/servo_rotate' */\r\n        ex5_StateChart1_Y.servo_rotate = 0;\r\n        ex5_StateChart1_DW.ctr_servo = 0U;\r\n        ex5_StateChart1_DW.is_Servo_Motor = ex5_StateChart1_IN_Natural;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_Natural: */\r\n      tmp_0 = rt_roundd_snf(ex5_StateChart1_U.switch_on * 5000.0);\r\n      if (tmp_0 < 65536.0) {\r\n        if (tmp_0 >= 0.0) {\r\n          tmp = (uint16_T)tmp_0;\r\n        } else {\r\n          tmp = 0U;\r\n        }\r\n      } else {\r\n        tmp = MAX_uint16_T;\r\n      }\r\n\r\n      /* MW:begin MISRA2012:D4.1 CERT-C:INT30-C 'Justifying MISRA CPP rule violation' */\r\n      qY = 10000U - /*MW:OvSatOk*/ tmp;\r\n\r\n      /* MW:end MISRA2012:D4.1 CERT-C:INT30-C */\r\n      if (tmp_0 < 65536.0) {\r\n        if (tmp_0 >= 0.0) {\r\n          tmp = (uint16_T)tmp_0;\r\n        } else {\r\n          tmp = 0U;\r\n        }\r\n      } else {\r\n        tmp = MAX_uint16_T;\r\n      }\r\n\r\n      if (10000U - tmp > 10000U) {\r\n        qY = 0U;\r\n      }\r\n\r\n      z = (int16_T)(qY / ex5_StateChart1_STEP_SIZE);\r\n      if (qY - (uint16_T)z * ex5_StateChart1_STEP_SIZE >= 50U) {\r\n        z = (int16_T)((uint16_T)z + 1U);\r\n      }\r\n\r\n      qY = (uint16_T)z - 1U;\r\n      if ((uint16_T)z - 1U > (uint16_T)z) {\r\n        qY = 0U;\r\n      }\r\n\r\n      if (ex5_StateChart1_DW.ctr_servo >= qY) {\r\n        /* Outport: '<Root>/servo_rotate' */\r\n        ex5_StateChart1_Y.servo_rotate = 1;\r\n        ex5_StateChart1_DW.ctr_servo = 0U;\r\n        ex5_StateChart1_DW.is_Servo_Motor = ex5_StateChart1_IN_ClockWise;\r\n      } else {\r\n        if (tmp_0 < 65536.0) {\r\n          if (tmp_0 >= 0.0) {\r\n            tmp = (uint16_T)tmp_0;\r\n          } else {\r\n            tmp = 0U;\r\n          }\r\n        } else {\r\n          tmp = MAX_uint16_T;\r\n        }\r\n\r\n        qY = 10000U - /*MW:OvSatOk*/ tmp;\r\n        if (tmp_0 < 65536.0) {\r\n          if (tmp_0 >= 0.0) {\r\n            tmp = (uint16_T)tmp_0;\r\n          } else {\r\n            tmp = 0U;\r\n          }\r\n        } else {\r\n          tmp = MAX_uint16_T;\r\n        }\r\n\r\n        if (10000U - tmp > 10000U) {\r\n          qY = 0U;\r\n        }\r\n\r\n        z = (int16_T)(qY / ex5_StateChart1_STEP_SIZE);\r\n        if (qY - (uint16_T)z * ex5_StateChart1_STEP_SIZE >= 50U) {\r\n          z = (int16_T)((uint16_T)z + 1U);\r\n        }\r\n\r\n        qY = (uint16_T)z - 1U;\r\n        if ((uint16_T)z - 1U > (uint16_T)z) {\r\n          qY = 0U;\r\n        }\r\n\r\n        if (ex5_StateChart1_DW.ctr_servo < qY) {\r\n          qY = ex5_StateChart1_DW.ctr_servo + /*MW:OvSatOk*/ 1U;\r\n          if (ex5_StateChart1_DW.ctr_servo + 1U < ex5_StateChart1_DW.ctr_servo)\r\n          {\r\n            qY = MAX_uint16_T;\r\n          }\r\n\r\n          ex5_StateChart1_DW.ctr_servo = qY;\r\n          ex5_StateChart1_DW.is_Servo_Motor = ex5_StateChart1_IN_Natural;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n\r\n    if (ex5_StateChart1_DW.ctr_dc < 9U) {\r\n      qY = ex5_StateChart1_DW.ctr_dc + /*MW:OvSatOk*/ 1U;\r\n      if (ex5_StateChart1_DW.ctr_dc + 1U < ex5_StateChart1_DW.ctr_dc) {\r\n        qY = MAX_uint16_T;\r\n      }\r\n\r\n      ex5_StateChart1_DW.ctr_dc = qY;\r\n    } else {\r\n      /* Outport: '<Root>/dc_speed' incorporates:\r\n       *  Constant: '<S1>/Constant'\r\n       *  Constant: '<S1>/Constant1'\r\n       *  Constant: '<S3>/Constant'\r\n       *  Gain: '<S1>/Gain'\r\n       *  Gain: '<S3>/Gain'\r\n       *  Inport: '<Root>/tmp_adc'\r\n       *  Sum: '<S1>/Sum'\r\n       *  Sum: '<S1>/Sum1'\r\n       *  Sum: '<S3>/Sum'\r\n       */\r\n      ex5_StateChart1_Y.dc_speed = (int16_T)((((((int16_T)((uint16_T)\r\n        ((((ex5_StateChart1_U.tmp_adc << 1) - 2560U) * 63985UL) >> 16) >> 1) +\r\n        -5120) << 1) - 5120) * 15165L) >> 14);\r\n      ex5_StateChart1_DW.ctr_dc = 0U;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<Root>/Chart1' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid ex5_StateChart1_initialize(void)\r\n{\r\n  /* (no initialization code required) */\r\n}\r\n\r\n/* Model terminate function */\r\nvoid ex5_StateChart1_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ex5_StateChart1.h","type":"header","group":"model","path":"C:\\Users\\erfuu\\OneDrive\\Courses\\Embedded and Realtime Systems\\Exercises\\ex7\\Simulink_3\\ex5_StateChart1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: ex5_StateChart1.h\r\n *\r\n * Code generated for Simulink model 'ex5_StateChart1'.\r\n *\r\n * Model version                  : 1.30\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 28 22:05:55 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ex5_StateChart1_h_\r\n#define ex5_StateChart1_h_\r\n#ifndef ex5_StateChart1_COMMON_INCLUDES_\r\n#define ex5_StateChart1_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                                 /* ex5_StateChart1_COMMON_INCLUDES_ */\r\n\r\n#include \"ex5_StateChart1_types.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  uint16_T ctr_dc;                     /* '<Root>/Chart1' */\r\n  uint16_T ctr_servo;                  /* '<Root>/Chart1' */\r\n  uint8_T is_active_c2_ex5_StateChart1;/* '<Root>/Chart1' */\r\n  uint8_T is_Servo_Motor;              /* '<Root>/Chart1' */\r\n} DW_ex5_StateChart1_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T switch_on;                    /* '<Root>/switch_on' */\r\n  uint16_T tmp_adc;                    /* '<Root>/tmp_adc' */\r\n} ExtU_ex5_StateChart1_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  int16_T servo_rotate;                /* '<Root>/servo_rotate' */\r\n  int16_T dc_speed;                    /* '<Root>/dc_speed' */\r\n} ExtY_ex5_StateChart1_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_ex5_StateChart1_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block states (default storage) */\r\nextern DW_ex5_StateChart1_T ex5_StateChart1_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU_ex5_StateChart1_T ex5_StateChart1_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_ex5_StateChart1_T ex5_StateChart1_Y;\r\n\r\n/* Model entry point functions */\r\nextern void ex5_StateChart1_initialize(void);\r\nextern void ex5_StateChart1_step(void);\r\nextern void ex5_StateChart1_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_ex5_StateChart1_T *const ex5_StateChart1_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'ex5_StateChart1'\r\n * '<S1>'   : 'ex5_StateChart1/CelsiusScaler Subsystem'\r\n * '<S2>'   : 'ex5_StateChart1/Chart1'\r\n * '<S3>'   : 'ex5_StateChart1/Subsystem'\r\n */\r\n#endif                                 /* ex5_StateChart1_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ex5_StateChart1_private.h","type":"header","group":"model","path":"C:\\Users\\erfuu\\OneDrive\\Courses\\Embedded and Realtime Systems\\Exercises\\ex7\\Simulink_3\\ex5_StateChart1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: ex5_StateChart1_private.h\r\n *\r\n * Code generated for Simulink model 'ex5_StateChart1'.\r\n *\r\n * Model version                  : 1.30\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 28 22:05:55 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ex5_StateChart1_private_h_\r\n#define ex5_StateChart1_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"ex5_StateChart1_types.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFU) ) || ( INT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFUL) ) || ( LONG_MAX != (0x7FFFFFFFL) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\nextern real_T rt_roundd_snf(real_T u);\r\n\r\n#endif                                 /* ex5_StateChart1_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ex5_StateChart1_types.h","type":"header","group":"model","path":"C:\\Users\\erfuu\\OneDrive\\Courses\\Embedded and Realtime Systems\\Exercises\\ex7\\Simulink_3\\ex5_StateChart1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: ex5_StateChart1_types.h\r\n *\r\n * Code generated for Simulink model 'ex5_StateChart1'.\r\n *\r\n * Model version                  : 1.30\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 28 22:05:55 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ex5_StateChart1_types_h_\r\n#define ex5_StateChart1_types_h_\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_ex5_StateChart1_T RT_MODEL_ex5_StateChart1_T;\r\n\r\n#endif                                 /* ex5_StateChart1_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\erfuu\\OneDrive\\Courses\\Embedded and Realtime Systems\\Exercises\\ex7\\Simulink_3\\ex5_StateChart1_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'ex5_StateChart1'.\r\n *\r\n * Model version                  : 1.30\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 28 22:05:55 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Atmel->AVR\r\n *   Number of bits:     char:   8    short:   16    int:  16\r\n *                       long:  32\r\n *                       native word size:   8\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef int int16_T;\r\ntypedef unsigned int uint16_T;\r\ntypedef long int32_T;\r\ntypedef unsigned long uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647L))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\erfuu\\OneDrive\\Courses\\Embedded and Realtime Systems\\Exercises\\ex7\\Simulink_3\\ex5_StateChart1_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'ex5_StateChart1'.\r\n *\r\n * Model version                  : 1.30\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 28 22:05:55 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"ex5_StateChart1.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};